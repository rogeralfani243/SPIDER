// components/SearchResults.jsx - version finalement corrig√©e
import React, { useState, useEffect, useCallback, useRef } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';
import { useSearch } from '../../hooks/useSearch';
import SearchBar from './searchBarMain';
import PostCard from '../posts/PostCard';
import { GroupCard } from './GroupCard';
import URL from '../../hooks/useUrl';
import ProfileSearchResults from './ProfileSearchResults';
import { groupAPI } from '../../hooks/messaging/messagingApi';
import '../../styles/search-result.css';

const SearchResults = ({ onClose }) => {
  const location = useLocation();
  const navigate = useNavigate();
  const { 
    results, 
    loading, 
    error, 
    type,
    search, 
    setType
  } = useSearch();
  
  const [showFilters, setShowFilters] = useState(false);
  const [hoveredCard, setHoveredCard] = useState(null);
  const [currentUser, setCurrentUser] = useState(null);
  
  // Posts state
  const [searchPosts, setSearchPosts] = useState([]);
  const [allPosts, setAllPosts] = useState([]);
  const [postsLoading, setPostsLoading] = useState(false);
  const [postsError, setPostsError] = useState('');
  const [postsPage, setPostsPage] = useState(1);
  const [hasMorePosts, setHasMorePosts] = useState(true);
  
  // Profiles state
  const [searchProfiles, setSearchProfiles] = useState([]);
  const [allProfiles, setAllProfiles] = useState([]);
  const [profilesLoading, setProfilesLoading] = useState(false);
  const [profilesError, setProfilesError] = useState(null);
  const [profileCategories, setProfileCategories] = useState([]);
  
  // Groups state
  const [searchGroups, setSearchGroups] = useState([]);
  const [allGroups, setAllGroups] = useState([]);
  const [groupsLoading, setGroupsLoading] = useState(false);
  const [groupsError, setGroupsError] = useState(null);
  const [groupCategories, setGroupCategories] = useState([]);
  const [groupsPage, setGroupsPage] = useState(1);
  const [hasMoreGroups, setHasMoreGroups] = useState(true);

  // Refs pour √©viter les boucles infinies et les appels inutiles
  const hasInitialized = useRef(false);
  const lastQuery = useRef('');
  const lastType = useRef('');

  // Fetch current user
  const fetchCurrentUser = useCallback(async () => {
    try {
      const token = localStorage.getItem('token');
      if (!token) {
        setCurrentUser(null);
        return;
      }

      const response = await fetch(`${URL}/api/auth/user/`, {
        headers: {
          'Authorization': `Token ${token}`,
          'Content-Type': 'application/json'
        },
        credentials: 'include'
      });

      if (response.ok) {
        const userData = await response.json();
        setCurrentUser(userData);
        localStorage.setItem('currentUser', JSON.stringify(userData));
      } else {
        setCurrentUser(null);
      }
    } catch (err) {
      console.error('Error fetching current user:', err);
      setCurrentUser(null);
    }
  }, []);

  // Fetch ALL posts
  const fetchAllPosts = useCallback(async (reset = false, page = 1) => {
    try {
      setPostsLoading(true);
      setPostsError('');
      
      const token = localStorage.getItem('token');
      const currentPage = reset ? 1 : page;

      const params = new URLSearchParams({
        page: currentPage,
        page_size: 20,
        sort: 'newest'
      });

      const url = `${URL}/post/posts/?${params.toString()}`;
      console.log('üìù Fetching all posts from:', url);

      const response = await fetch(url, {
        headers: {
          'Authorization': token ? `Token ${token}` : '',
        },
        credentials: 'include'
      });

      if (!response.ok) {
        const errorText = await response.text();
        console.error('‚ùå Posts API Error:', errorText);
        throw new Error(`Error ${response.status}: ${response.statusText}`);
      }

      const data = await response.json();
      console.log('üì¶ All posts response:', data);

      let postsArray = [];
      
      if (Array.isArray(data)) {
        postsArray = data;
      } else if (data.posts && Array.isArray(data.posts)) {
        postsArray = data.posts;
      } else if (data.results && Array.isArray(data.results)) {
        postsArray = data.results;
      } else if (Array.isArray(data.data)) {
        postsArray = data.data;
      } else {
        for (const key in data) {
          if (Array.isArray(data[key])) {
            postsArray = data[key];
            break;
          }
        }
      }

      if (reset) {
        setAllPosts(postsArray);
      } else {
        setAllPosts(prev => [...prev, ...postsArray]);
      }

      // Check if there are more posts to load
      if (data.next) {
        setHasMorePosts(true);
      } else if (data.pagination?.has_next !== undefined) {
        setHasMorePosts(data.pagination.has_next);
      } else if (data.has_next !== undefined) {
        setHasMorePosts(data.has_next);
      } else {
        setHasMorePosts(postsArray.length >= 20);
      }

    } catch (err) {
      console.error('Fetch all posts error:', err);
      setPostsError(err.message || 'Failed to load posts');
    } finally {
      setPostsLoading(false);
    }
  }, []);

  // Fetch ALL profiles
  const fetchAllProfiles = useCallback(async () => {
    try {
      setProfilesLoading(true);
      setProfilesError(null);
      
      const apiUrl = `${URL}/api/profiles/category/`;
      const response = await fetch(apiUrl, {
        method: 'GET',
        headers: {
          'Content-Type': 'application/json',
        },
        credentials: 'include'
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      const data = await response.json();
      
      // Flatten all profiles from all categories
      const allProfilesArray = [];
      data.forEach(category => {
        if (category.profiles && Array.isArray(category.profiles)) {
          allProfilesArray.push(...category.profiles.map(profile => ({
            ...profile,
            category_id: category.category_id,
            category_name: category.category_name
          })));
        }
      });
      
      setAllProfiles(allProfilesArray);
      setProfileCategories(data);
      
      console.log('üë§ Fetched', allProfilesArray.length, 'profiles');
      
    } catch (err) {
      console.error('Error fetching all profiles:', err);
      setProfilesError(err.message);
    } finally {
      setProfilesLoading(false);
    }
  }, []);

  // Fetch ALL groups
  const fetchAllGroups = useCallback(async (reset = false, page = 1) => {
    try {
      setGroupsLoading(true);
      setGroupsError(null);
      
      const params = {
        page: page,
        limit: 12,
        sort: 'newest',
      };
      
      console.log('üë• Fetching all groups with params:', params);
      
      const response = await groupAPI.exploreGroups(params);
      
      const groupsData = response.data.results || response.data || [];
      
      if (reset) {
        setAllGroups(groupsData);
      } else {
        setAllGroups(prev => [...prev, ...groupsData]);
      }
      
      // Check if there are more groups to load
      if (response.data.next) {
        setHasMoreGroups(true);
      } else {
        setHasMoreGroups(groupsData.length >= 12);
      }
      
      console.log('üë• Fetched', groupsData.length, 'groups');
      
    } catch (err) {
      console.error('Error fetching all groups:', err);
      setGroupsError(err.response?.data?.error || 'Failed to load groups. Please try again.');
    } finally {
      setGroupsLoading(false);
    }
  }, []);

  // Load group categories
  const loadGroupCategories = async () => {
    try {
      const response = await groupAPI.getCategories();
      setGroupCategories(response.data || []);
    } catch (err) {
      console.error('Error loading group categories:', err);
      setGroupCategories([]);
    }
  };

  // Filter posts based on search query
  const filterPosts = useCallback((query = '', posts = allPosts) => {
    if (!query.trim()) {
      const filteredPosts = posts;
      setSearchPosts(filteredPosts);
      return filteredPosts;
    }
    
    const searchLower = query.toLowerCase();
    const filtered = posts.filter(post => {
      return (
        (post.title && post.title.toLowerCase().includes(searchLower)) ||
        (post.content && post.content.toLowerCase().includes(searchLower)) ||
        (post.user?.username && post.user.username.toLowerCase().includes(searchLower)) ||
        (post.tags && Array.isArray(post.tags) && post.tags.some(tag => 
          tag.toLowerCase().includes(searchLower)
        ))
      );
    });
    
    setSearchPosts(filtered);
    return filtered;
  }, [allPosts]);

  // Filter profiles based on search query
  const filterProfiles = useCallback((query = '', profiles = allProfiles) => {
    if (!query.trim()) {
      const filteredProfiles = profiles;
      setSearchProfiles(filteredProfiles);
      return filteredProfiles;
    }
    
    const searchLower = query.toLowerCase();
    const filtered = profiles.filter(profile => {
      return (
        (profile.first_name && profile.first_name.toLowerCase().includes(searchLower)) ||
        (profile.last_name && profile.last_name.toLowerCase().includes(searchLower)) ||
        (profile.username && profile.username.toLowerCase().includes(searchLower)) ||
        (profile.bio && profile.bio.toLowerCase().includes(searchLower)) ||
        (profile.title && profile.title.toLowerCase().includes(searchLower))
      );
    });
    
    setSearchProfiles(filtered);
    return filtered;
  }, [allProfiles]);

  // Filter groups based on search query
  const filterGroups = useCallback((query = '', groups = allGroups) => {
    if (!query.trim()) {
      const filteredGroups = groups;
      setSearchGroups(filteredGroups);
      return filteredGroups;
    }
    
    const searchLower = query.toLowerCase();
    const filtered = groups.filter(group => {
      return (
        (group.name && group.name.toLowerCase().includes(searchLower)) ||
        (group.description && group.description.toLowerCase().includes(searchLower)) ||
        (group.tags && Array.isArray(group.tags) && group.tags.some(tag => 
          tag.toLowerCase().includes(searchLower)
        )) ||
        (group.category?.name && group.category.name.toLowerCase().includes(searchLower))
      );
    });
    
    setSearchGroups(filtered);
    return filtered;
  }, [allGroups]);

  // Fonction pour charger toutes les donn√©es
  const loadAllData = useCallback(async (shouldExecuteSearch = true) => {
    try {
      console.log('üîÑ Loading all data...');
      
      // Charger les cat√©gories de groupes
      await loadGroupCategories();
      
      // Charger l'utilisateur courant
      await fetchCurrentUser();
      
      // Charger les donn√©es initiales en parall√®le
      await Promise.all([
        fetchAllPosts(true, 1),
        fetchAllProfiles(),
        fetchAllGroups(true, 1)
      ]);
      
      console.log('‚úÖ All data loaded successfully');
      
      // Si sp√©cifi√©, ex√©cuter la recherche apr√®s le chargement
      if (shouldExecuteSearch) {
        const params = new URLSearchParams(location.search);
        const query = params.get('q') || '';
        const urlType = params.get('type') || 'all';
        
        console.log('üîç Executing search after data load:', { query, urlType });
        
        // Mettre √† jour le type
        setType(urlType);
        
        // Appliquer le filtre
        if (query.trim()) {
          if (urlType === 'all' || urlType === 'posts') {
            filterPosts(query);
          }
          if (urlType === 'all' || urlType === 'profiles') {
            filterProfiles(query);
          }
          if (urlType === 'all' || urlType === 'groups') {
            filterGroups(query);
          }
        } else {
          // Si pas de requ√™te, montrer toutes les donn√©es
          setSearchPosts(allPosts);
          setSearchProfiles(allProfiles);
          setSearchGroups(allGroups);
        }
      }
    } catch (error) {
      console.error('‚ùå Error loading all data:', error);
    }
  }, [location.search, fetchCurrentUser, fetchAllPosts, fetchAllProfiles, fetchAllGroups, filterPosts, filterProfiles, filterGroups, setType, allPosts, allProfiles, allGroups]);

  // Fonction principale pour ex√©cuter la recherche
  const executeSearch = useCallback((query = '', searchType = type) => {
    console.log('üîç Executing search:', { query, searchType });
    
    // √âviter les appels inutiles
    if (lastQuery.current === query && lastType.current === searchType) {
      return;
    }
    
    lastQuery.current = query;
    lastType.current = searchType;
    
    // Mettre √† jour l'URL
    if (query) {
      navigate(`/search?q=${encodeURIComponent(query)}&type=${searchType}`, { replace: true });
    } else {
      navigate(`/search?type=${searchType}`, { replace: true });
    }
    
    // Mettre √† jour le type dans le hook useSearch
    setType(searchType);
    
    // Si pas de requ√™te, montrer toutes les donn√©es
    if (!query.trim()) {
      setSearchPosts(allPosts);
      setSearchProfiles(allProfiles);
      setSearchGroups(allGroups);
      return;
    }
    
    // Filtrer les donn√©es selon le type
    if (searchType === 'all' || searchType === 'posts') {
      filterPosts(query);
    } else {
      setSearchPosts([]);
    }
    
    if (searchType === 'all' || searchType === 'profiles') {
      filterProfiles(query);
    } else {
      setSearchProfiles([]);
    }
    
    if (searchType === 'all' || searchType === 'groups') {
      filterGroups(query);
    } else {
      setSearchGroups([]);
    }
  }, [allPosts, allProfiles, allGroups, filterPosts, filterProfiles, filterGroups, type, navigate, setType]);

  // Initialisation: charger les donn√©es au montage du composant
  useEffect(() => {
    console.log('üöÄ Component mounted, loading data...');
    loadAllData(true);
    
    // Nettoyage
    return () => {
      console.log('üßπ Component unmounting');
    };
  }, []); // Ex√©cuter seulement au montage

  // √âcouter les changements d'URL pour rafra√Æchir la recherche
  useEffect(() => {
    // Attendre un peu pour √©viter les conflits avec l'initialisation
    const timer = setTimeout(() => {
      const params = new URLSearchParams(location.search);
      const query = params.get('q') || '';
      const urlType = params.get('type') || 'all';
      
      console.log('üîÑ URL changed:', { query, urlType });
      
      // V√©rifier si les donn√©es sont charg√©es
      if (allPosts.length === 0 && allProfiles.length === 0 && allGroups.length === 0) {
        console.log('‚ö†Ô∏è Data not loaded yet, skipping search execution');
        return;
      }
      
      // Ex√©cuter la recherche
      executeSearch(query, urlType);
    }, 100);
    
    return () => clearTimeout(timer);
  }, [location.search]);

  // Re-filtrer les donn√©es lorsque les donn√©es sources changent
  useEffect(() => {
    const params = new URLSearchParams(location.search);
    const query = params.get('q') || '';
    const urlType = params.get('type') || 'all';
    
    if (query.trim() && (allPosts.length > 0 || allProfiles.length > 0 || allGroups.length > 0)) {
      console.log('üîÑ Re-filtering data based on source changes');
      
      if (urlType === 'all' || urlType === 'posts') {
        filterPosts(query);
      }
      if (urlType === 'all' || urlType === 'profiles') {
        filterProfiles(query);
      }
      if (urlType === 'all' || urlType === 'groups') {
        filterGroups(query);
      }
    }
  }, [allPosts, allProfiles, allGroups, location.search]);

  // Handler pour le changement de type
  const handleTypeChange = (newType) => {
    const params = new URLSearchParams(location.search);
    const query = params.get('q') || '';
    
    executeSearch(query, newType);
  };

  // Handler pour la recherche
  const handleSearch = (query, searchType = type) => {
    executeSearch(query, searchType);
  };

  // Handler pour le changement de recherche en temps r√©el
  const handleSearchChange = (query, searchType = type) => {
    executeSearch(query, searchType);
  };

  const loadMorePosts = () => {
    const nextPage = postsPage + 1;
    setPostsPage(nextPage);
    fetchAllPosts(false, nextPage).then(() => {
      // Apr√®s avoir charg√© plus de posts, re-filtrer si n√©cessaire
      const params = new URLSearchParams(location.search);
      const query = params.get('q') || '';
      if (query.trim() && (type === 'all' || type === 'posts')) {
        filterPosts(query);
      }
    });
  };

  const loadMoreGroups = () => {
    const nextPage = groupsPage + 1;
    setGroupsPage(nextPage);
    fetchAllGroups(false, nextPage).then(() => {
      // Apr√®s avoir charg√© plus de groupes, re-filtrer si n√©cessaire
      const params = new URLSearchParams(location.search);
      const query = params.get('q') || '';
      if (query.trim() && (type === 'all' || type === 'groups')) {
        filterGroups(query);
      }
    });
  };
  
  // Get all profiles from categories for ProfileSearchResults component
  const getAllProfilesForDisplay = () => {
    // Group profiles by category for the ProfileSearchResults component
    const categoriesMap = {};
    searchProfiles.forEach(profile => {
      const categoryId = profile.category_id || 'uncategorized';
      const categoryName = profile.category_name || 'Other';
      
      if (!categoriesMap[categoryId]) {
        categoriesMap[categoryId] = {
          category_id: categoryId,
          category_name: categoryName,
          profiles: []
        };
      }
      categoriesMap[categoryId].profiles.push(profile);
    });
    
    return Object.values(categoriesMap);
  };

  // Render GroupCard
  const renderGroupCard = (group) => {
    const cardProps = {
      key: group.id || `group-${Math.random()}`,
      group: group,
      onClick: () => {
        if (group.id) {
          console.log('Click group:', group.id);
          if (onClose) onClose();
          navigate(`/groups/${group.id}`);
        }
      },
      onJoinRequest: async (groupId) => {
        try {
          const response = await groupAPI.requestToJoin(groupId);
          let message = response.data.message || 'Join request sent successfully!';
          
          if (!message && response.data.success === true) {
            message = 'Request sent successfully!';
          }
          
          alert(message);
          fetchAllGroups(true, 1);
        } catch (err) {
          let errorMessage = err.response?.data?.error || 
                            err.response?.data?.detail || 
                            'Failed to send join request';
          alert(errorMessage);
        }
      },
      isHovered: hoveredCard === group.id,
      onMouseEnter: () => group.id && setHoveredCard(group.id),
      onMouseLeave: () => group.id && setHoveredCard(null),
      compact: true,
      showDescription: false,
      showStats: true,
      className: "search-group-card",
      isSearchResult: true
    };
    
    return <GroupCard {...cardProps} />;
  };
  
  // Render PostCard
  const renderPostCard = (post) => {
    if (!post) return null;
    
    return (
      <div className="post-card-wrapper" data-post-id={post.id}>
        <PostCard 
          currentUser={currentUser}
          post={post}
          URL={URL}
          isMobile={window.innerWidth <= 768}
          onToggleExpand={(postId) => {
            setSearchPosts(prevPosts =>
              prevPosts.map(p =>
                p.id === postId ? { ...p, expanded: !p.expanded } : p
              )
            );
          }}
          onToggleShowAllMedia={(postId) => {
            setSearchPosts(prevPosts =>
              prevPosts.map(p =>
                p.id === postId ? { ...p, showAllMedia: !p.showAllMedia } : p
              )
            );
          }}
          onThumbnailClick={(postId, mediaUrls, mediaIndex) => {
            console.log('Thumbnail clicked:', { postId, mediaIndex });
          }}
          onOpenGallery={(postId, mediaUrls) => {
            console.log('Open gallery for post:', postId);
          }}
          onLike={(postId) => {
            console.log('Like post:', postId);
          }}
          onToggleComments={(postId) => {
            navigate(`/post/${postId}`);
          }}
          onAddComment={(postId, comment) => {
            console.log('Add comment to post:', postId, comment);
          }}
          onCommentChange={(postId, commentId, newContent) => {
            console.log('Edit comment:', { postId, commentId, newContent });
          }}
          onViewPost={(postId) => {
            navigate(`/post/${postId}`);
          }}
          onEditPost={(post) => {
            console.log('Edit post requested:', post.id);
            navigate(`/posts/edit/${post.id}`);
          }}
          onDeletePost={async (post) => {
            const token = localStorage.getItem('token');
            
            if (!window.confirm('Are you sure you want to delete this post?')) {
              return;
            }

            try {
              const response = await fetch(`${URL}/post/posts/${post.id}/`, {
                method: 'DELETE',
                headers: {
                  'Authorization': token ? `Token ${token}` : '',
                },
              });

              if (response.ok) {
                setSearchPosts(prev => prev.filter(p => p.id !== post.id));
                setAllPosts(prev => prev.filter(p => p.id !== post.id));
              } else {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to delete post');
              }
            } catch (err) {
              console.error('Error deleting post:', err);
              alert(err.message || 'Failed to delete post');
            }
          }}
          onReportPost={async (post, reason) => {
            const token = localStorage.getItem('token');
            
            if (!token) {
              alert('You must be logged in to report a post');
              return;
            }

            try {
              const response = await fetch(`${URL}/post/posts/${post.id}/report/`, {
                method: 'POST',
                headers: {
                  'Authorization': `Token ${token}`,
                  'Content-Type': 'application/json',
                },
                body: JSON.stringify({ reason: reason }),
              });

              if (response.ok) {
                alert('Post reported successfully');
                return true;
              } else {
                const errorData = await response.json();
                throw new Error(errorData.error || 'Failed to report post');
              }
            } catch (err) {
              console.error('Error reporting post:', err);
              alert(err.message || 'Failed to report post');
              return false;
            }
          }}
          onSharePost={(post) => {
            if (navigator.share) {
              navigator.share({
                title: post.title || 'Post',
                text: post.content?.substring(0, 100) || '',
                url: `${window.location.origin}/post/${post.id}`,
              });
            } else {
              navigator.clipboard.writeText(`${window.location.origin}/post/${post.id}`);
              alert('Post link copied to clipboard!');
            }
          }}
          onRatingUpdate={async (postId, ratingData) => {
            console.log('Rating updated for post', postId, ':', ratingData);
          }}
          showUserBio={false}
          userBio={''}
        />
      </div>
    );
  };
  
  // Get stats based on filtered data
  const getStats = () => {
    return {
      profiles: searchProfiles.length,
      posts: searchPosts.length,
      groups: searchGroups.length,
      categories: 0,
      tags: 0,
    };
  };
  
  const stats = getStats();
  
  // Get total count for "All" tab
  const getTotalCount = () => {
    return stats.posts + stats.profiles + stats.groups;
  };
  
  // Charger plus de posts quand postsPage change
  useEffect(() => {
    if (postsPage > 1) {
      fetchAllPosts(false, postsPage);
    }
  }, [postsPage]);

  // Charger plus de groupes quand groupsPage change
  useEffect(() => {
    if (groupsPage > 1) {
      fetchAllGroups(false, groupsPage);
    }
  }, [groupsPage]);

  // Calculer le chargement global
  const isLoading = postsLoading || profilesLoading || groupsLoading;
  const hasError = postsError || profilesError || groupsError;
  const totalResults = getTotalCount();
  const params = new URLSearchParams(location.search);
  const currentQuery = params.get('q') || '';

  return (
    <div className="search-results-page">
      {/* Header with SearchBar and close button */}
      <div className="search-results-header">
        <div className="searh-container">
          <SearchBar
            initialType={type}
            showTypeFilter={false}
            onSearch={handleSearch}
            onSearchChange={handleSearchChange}
            className="results-search-bar"
            debounceTime={300}
          />
        </div>
      </div>
      
      {/* Type tabs */}
      <div className="search-type-tabs">
        {[
          { id: 'all', label: 'All', count: totalResults },
          { id: 'profiles', label: 'Profiles', count: stats.profiles },
          { id: 'posts', label: 'Posts', count: stats.posts },
          { id: 'groups', label: 'Groups', count: stats.groups },
        ].map(tab => (
          <button
            key={tab.id}
            className={`type-tab ${type === tab.id ? 'active' : ''}`}
            onClick={() => handleTypeChange(tab.id)}
            disabled={isLoading}
          >
            {tab.label}
            {tab.count > 0 && <span className="tab-count">{tab.count}</span>}
          </button>
        ))}
      </div>
      
      {/* Results content */}
      <div className="results-content">
        {isLoading ? (
          <div className="loading-state">
            <div className="spinner large"></div>
            <p>Loading search results...</p>
          </div>
        ) : hasError ? (
          <div className="error-state">
            <div className="error-icon">‚ö†Ô∏è</div>
            <h3>Error loading data</h3>
            <p>{postsError || profilesError || groupsError}</p>
            <button 
              className="retry-btn"
              onClick={() => loadAllData(true)}
            >
              Try again
            </button>
          </div>
        ) : currentQuery && totalResults > 0 ? (
          <>
            {/* Summary */}
            <div className="results-summary">
              <p>
                <strong>{totalResults}</strong> 
                result{totalResults > 1 ? 's' : ''} found for "<strong>{currentQuery}</strong>"
              </p>
            </div>
            
            {/* Results grid */}
            <div className="results-grid">
              {/* Profiles - Only show when type is profiles or all */}
              {(type === 'all' || type === 'profiles') && (
                <div className="result-section">
                  <div className="section-header">
                    <h3 className="section-title">Profiles</h3>
                    <span className="section-count">
                      {stats.profiles} result{stats.profiles > 1 ? 's' : ''}
                    </span>
                  </div>
                  
                  {searchProfiles.length > 0 ? (
                    <ProfileSearchResults
                      profiles={searchProfiles}
                      query={currentQuery}
                      loading={profilesLoading}
                      error={profilesError}
                      onProfileClick={(profileId) => {
                        if (onClose) onClose();
                        navigate(`/profile/${profileId}`);
                      }}
                    />
                  ) : (
                    <div className="no-results-subsection">
                      <p>No profiles found</p>
                    </div>
                  )}
                </div>
              )}
              
              {/* Posts - Only show when type is posts or all */}
              {(type === 'all' || type === 'posts') && (
                <div className="result-section">
                  <div className="section-header">
                    <h3 className="section-title">Posts</h3>
                    <span className="section-count">
                      {stats.posts} result{stats.posts > 1 ? 's' : ''}
                    </span>
                  </div>
                  
                  {searchPosts.length > 0 ? (
                    <>
                      <div className="posts-grid">
                        {searchPosts.map(renderPostCard)}
                      </div>
                      
                      {/* "Load more" button for posts */}
                      {hasMorePosts && type === 'posts' && (
                        <div className="load-more-container">
                          <button 
                            onClick={loadMorePosts} 
                            disabled={postsLoading}
                            className="btn-load-more"
                          >
                            {postsLoading ? (
                              <>
                                <i className="fas fa-spinner fa-spin"></i> Loading...
                              </>
                            ) : (
                              <>
                                <i className="fas fa-arrow-down"></i> Load more posts
                              </>
                            )}
                          </button>
                        </div>
                      )}
                    </>
                  ) : (
                    <div className="no-results-subsection">
                      <p>No posts found</p>
                    </div>
                  )}
                </div>
              )}
              
              {/* Groups - Only show when type is groups or all */}
              {(type === 'all' || type === 'groups') && (
                <div className="result-section">
                  <div className="section-header">
                    <h3 className="section-title">Groups</h3>
                    <span className="section-count">
                      {stats.groups} result{stats.groups > 1 ? 's' : ''}
                    </span>
                  </div>
                  
                  {searchGroups.length > 0 ? (
                    <>
                      <div className="groups-grid">
                        {searchGroups.map(renderGroupCard)}
                      </div>
                      
                      {/* Load more groups button */}
                      {hasMoreGroups && type === 'groups' && (
                        <div className="load-more-container">
                          <button 
                            onClick={loadMoreGroups} 
                            disabled={groupsLoading}
                            className="btn-load-more"
                          >
                            {groupsLoading ? (
                              <>
                                <i className="fas fa-spinner fa-spin"></i> Loading...
                              </>
                            ) : (
                              <>
                                <i className="fas fa-arrow-down"></i> Load more groups
                              </>
                            )}
                          </button>
                        </div>
                      )}
                    </>
                  ) : (
                    <div className="no-results-subsection">
                      <p>No groups found</p>
                    </div>
                  )}
                </div>
              )}
            </div>
          </>
        ) : currentQuery && totalResults === 0 ? (
          <div className="empty-state">
            <div className="empty-icon">üîç</div>
            <h3>No results found for "{currentQuery}"</h3>
            <p>Try different search terms or check your spelling</p>
          </div>
        ) : !currentQuery ? (
          <div className="initial-state">
            <div className="initial-icon">üîç</div>
            <h3>Start your search</h3>
            <p>Type something in the search bar above to begin</p>
            
            {/* Show some recent data if available */}
            {(allPosts.length > 0 || allProfiles.length > 0 || allGroups.length > 0) && (
              <div className="recent-data-preview">
                <p className="preview-title">Recent content available:</p>
                <div className="preview-stats">
                  {allPosts.length > 0 && <span>{allPosts.length} posts</span>}
                  {allProfiles.length > 0 && <span>{allProfiles.length} profiles</span>}
                  {allGroups.length > 0 && <span>{allGroups.length} groups</span>}
                </div>
              </div>
            )}
          </div>
        ) : null}
      </div>
    </div>
  );
};

export default SearchResults;